<?php

declare(strict_types=1);

namespace {{{validatorNamespace}}};

use Respect\Validation\Validator as v;
use Respect\Validation\Exceptions\NestedValidationException;

/**
 * {{{operationIdCamelCase}}}Validator
 *
 * Validates input for {{{operationId}}} operation using Respect/Validation.
{{#summary}}
 * {{{summary}}}
{{/summary}}
 *
 * @generated
 */
{{#validatorFinal}}final {{/validatorFinal}}class {{{operationIdCamelCase}}}Validator
{
    /**
     * Validate the input data
     *
     * @param array<string, mixed> $data
     * @return ValidationResult
     */
    public function validate(array $data): ValidationResult
    {
        $errors = [];

{{#allParams}}
{{#isPathParam}}
        // Validate path parameter: {{{paramName}}}
        ${{{paramName}}}Validator = {{^required}}v::optional({{/required}}v::{{#isString}}stringType(){{/isString}}{{#isInteger}}intType(){{/isInteger}}{{#isLong}}intType(){{/isLong}}{{#isFloat}}floatType(){{/isFloat}}{{#isDouble}}floatType(){{/isDouble}}{{#isBoolean}}boolType(){{/isBoolean}}{{#isArray}}arrayType(){{/isArray}}{{#isEmail}}->email(){{/isEmail}}{{#isUuid}}->uuid(){{/isUuid}}{{#isUri}}->url(){{/isUri}}{{#minimum}}->min({{{minimum}}}){{/minimum}}{{#maximum}}->max({{{maximum}}}){{/maximum}}{{#minLength}}->length({{{minLength}}}, null){{/minLength}}{{#maxLength}}->length(null, {{{maxLength}}}){{/maxLength}}{{#pattern}}->regex('/{{{pattern}}}/'){{/pattern}}{{#isEnum}}->in([{{#allowableValues}}{{#values}}'{{{.}}}'{{^-last}}, {{/-last}}{{/values}}{{/allowableValues}}]){{/isEnum}}{{^required}}){{/required}};
        try {
            ${{{paramName}}}Validator->assert($data['{{{paramName}}}'] ?? null);
        } catch (NestedValidationException $e) {
            $errors['{{{paramName}}}'] = $e->getMessages();
        }

{{/isPathParam}}
{{#isQueryParam}}
        // Validate query parameter: {{{paramName}}}
        ${{{paramName}}}Validator = {{^required}}v::optional({{/required}}v::{{#isString}}stringType(){{/isString}}{{#isInteger}}intType(){{/isInteger}}{{#isLong}}intType(){{/isLong}}{{#isFloat}}floatType(){{/isFloat}}{{#isDouble}}floatType(){{/isDouble}}{{#isBoolean}}boolType(){{/isBoolean}}{{#isArray}}arrayType(){{/isArray}}{{#isEmail}}->email(){{/isEmail}}{{#isUuid}}->uuid(){{/isUuid}}{{#isUri}}->url(){{/isUri}}{{#minimum}}->min({{{minimum}}}){{/minimum}}{{#maximum}}->max({{{maximum}}}){{/maximum}}{{#minLength}}->length({{{minLength}}}, null){{/minLength}}{{#maxLength}}->length(null, {{{maxLength}}}){{/maxLength}}{{#pattern}}->regex('/{{{pattern}}}/'){{/pattern}}{{#isEnum}}->in([{{#allowableValues}}{{#values}}'{{{.}}}'{{^-last}}, {{/-last}}{{/values}}{{/allowableValues}}]){{/isEnum}}{{^required}}){{/required}};
        try {
            ${{{paramName}}}Validator->assert($data['{{{paramName}}}'] ?? null);
        } catch (NestedValidationException $e) {
            $errors['{{{paramName}}}'] = $e->getMessages();
        }

{{/isQueryParam}}
{{#isBodyParam}}
        // Validate request body
        if (isset($data['body'])) {
            // Body validation is typically handled by the model's own validation
            // Additional custom validation can be added here
        }{{#required}} else {
            $errors['body'] = ['Request body is required'];
        }{{/required}}

{{/isBodyParam}}
{{/allParams}}
        return new ValidationResult(empty($errors), $errors);
    }
}

/**
 * Validation result container
 */
final class ValidationResult
{
    /**
     * @param array<string, array<string>> $errors
     */
    public function __construct(
        private readonly bool $valid,
        private readonly array $errors = []
    ) {}

    public function isValid(): bool
    {
        return $this->valid;
    }

    /** @return array<string, array<string>> */
    public function getErrors(): array
    {
        return $this->errors;
    }
}
