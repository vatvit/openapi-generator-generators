<?php declare(strict_types=1);

namespace {{apiPackage}}\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use {{apiPackage}}\Security\{{interfaceName}};

/**
 * {{middlewareClassName}}
 *
 * EXAMPLE authentication middleware for {{schemeName}} security scheme
 *
 * This is an EXAMPLE STUB - customize this for your application's auth needs.
 *
{{#isHttp}}
{{#isBearerAuth}}
 * OpenAPI Security: Bearer HTTP Authentication (JWT)
 *
 * In a real application, you would:
 * - Validate JWT tokens (using firebase/php-jwt or similar)
 * - Verify token signature with public key
 * - Check expiration (exp claim)
 * - Load user from database
{{/isBearerAuth}}
{{#isBasicAuth}}
 * OpenAPI Security: Basic HTTP Authentication
 *
 * In a real application, you would:
 * - Decode Base64 credentials from Authorization header
 * - Verify username and password against your user store
 * - Load user into request context
{{/isBasicAuth}}
{{/isHttp}}
{{#isApiKey}}
 * OpenAPI Security: API Key ({{apiKeyIn}}: {{apiKeyName}})
 *
 * In a real application, you would:
 * - Extract API key from {{apiKeyIn}} named '{{apiKeyName}}'
 * - Validate against your key store or database
 * - Associate request with API key owner
{{/isApiKey}}
{{#isOAuth2}}
 * OpenAPI Security: OAuth2
 *
 * In a real application, you would:
 * - Extract Bearer token from Authorization header
 * - Validate token against your OAuth2 server
 * - Check required scopes
 * - Load user/client from token claims
{{/isOAuth2}}
 *
 * USAGE in bootstrap/app.php:
 * ```php
 * ->withMiddleware(function (Middleware $middleware): void {
 *     $middleware->group('api.security.{{schemeName}}', [
 *         \{{apiPackage}}\Http\Middleware\{{middlewareClassName}}::class,
 *     ]);
 * })
 * ```
 */
class {{middlewareClassName}} implements {{interfaceName}}
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
{{#isHttp}}
{{#isBearerAuth}}
        // Extract Authorization header
        $authHeader = $request->header('Authorization');

        if (!$authHeader) {
            return $this->unauthorized('Missing Authorization header');
        }

        // Validate Bearer token format
        if (!str_starts_with($authHeader, 'Bearer ')) {
            return $this->unauthorized('Invalid Authorization header format. Expected: Bearer {token}');
        }

        // Extract token
        $token = substr($authHeader, 7); // Remove "Bearer " prefix

        if (empty($token)) {
            return $this->unauthorized('Bearer token is empty');
        }

        // TODO: Implement real JWT validation
        // In production:
        // - Decode JWT using firebase/php-jwt or similar
        // - Verify signature with public key
        // - Check expiration (exp claim)
        // - Verify issuer (iss claim) and audience (aud claim)
        //
        // Example with firebase/php-jwt:
        // try {
        //     $payload = JWT::decode($token, new Key($publicKey, 'RS256'));
        //     $request->attributes->set('user_id', $payload->sub);
        // } catch (\Exception $e) {
        //     return $this->unauthorized('Invalid token: ' . $e->getMessage());
        // }

        // STUB: Accept any non-empty token for testing
        // REMOVE THIS IN PRODUCTION
        $request->attributes->set('auth_token', $token);
{{/isBearerAuth}}
{{#isBasicAuth}}
        // Extract Authorization header
        $authHeader = $request->header('Authorization');

        if (!$authHeader) {
            return $this->unauthorized('Missing Authorization header');
        }

        // Validate Basic auth format
        if (!str_starts_with($authHeader, 'Basic ')) {
            return $this->unauthorized('Invalid Authorization header format. Expected: Basic {base64}');
        }

        // Decode credentials
        $credentials = base64_decode(substr($authHeader, 6));
        if ($credentials === false || !str_contains($credentials, ':')) {
            return $this->unauthorized('Invalid Basic auth credentials');
        }

        [$username, $password] = explode(':', $credentials, 2);

        // TODO: Implement real credential validation
        // In production:
        // - Verify username/password against your user store
        // - Load user and attach to request
        //
        // Example:
        // $user = User::where('email', $username)->first();
        // if (!$user || !Hash::check($password, $user->password)) {
        //     return $this->unauthorized('Invalid credentials');
        // }
        // $request->attributes->set('user', $user);

        // STUB: Accept any credentials for testing
        // REMOVE THIS IN PRODUCTION
        $request->attributes->set('auth_username', $username);
{{/isBasicAuth}}
{{/isHttp}}
{{#isApiKey}}
        // Extract API key from {{apiKeyIn}}
{{#apiKeyInHeader}}
        $apiKey = $request->header('{{apiKeyName}}');
{{/apiKeyInHeader}}
{{#apiKeyInQuery}}
        $apiKey = $request->query('{{apiKeyName}}');
{{/apiKeyInQuery}}
{{#apiKeyInCookie}}
        $apiKey = $request->cookie('{{apiKeyName}}');
{{/apiKeyInCookie}}

        if (!$apiKey) {
            return $this->unauthorized('Missing API key in {{apiKeyIn}}: {{apiKeyName}}');
        }

        // TODO: Implement real API key validation
        // In production:
        // - Verify API key against your key store
        // - Check key permissions/scopes
        // - Associate request with key owner
        //
        // Example:
        // $keyRecord = ApiKey::where('key', hash('sha256', $apiKey))->first();
        // if (!$keyRecord || $keyRecord->revoked_at) {
        //     return $this->unauthorized('Invalid or revoked API key');
        // }
        // $request->attributes->set('api_key_owner', $keyRecord->user_id);

        // STUB: Accept any non-empty key for testing
        // REMOVE THIS IN PRODUCTION
        $request->attributes->set('api_key', $apiKey);
{{/isApiKey}}
{{#isOAuth2}}
        // Extract OAuth2 Bearer token
        $authHeader = $request->header('Authorization');

        if (!$authHeader) {
            return $this->unauthorized('Missing Authorization header');
        }

        if (!str_starts_with($authHeader, 'Bearer ')) {
            return $this->unauthorized('Invalid Authorization header format. Expected: Bearer {token}');
        }

        $token = substr($authHeader, 7);

        if (empty($token)) {
            return $this->unauthorized('Bearer token is empty');
        }

        // TODO: Implement real OAuth2 token validation
        // In production:
        // - Validate token against OAuth2 server (introspection endpoint)
        // - Or decode JWT if using JWT tokens
        // - Verify required scopes
        //
        // Example with token introspection:
        // $response = Http::asForm()->post($introspectionUrl, [
        //     'token' => $token,
        //     'client_id' => $clientId,
        //     'client_secret' => $clientSecret,
        // ]);
        // if (!$response->json('active')) {
        //     return $this->unauthorized('Token is inactive or expired');
        // }

        // STUB: Accept any non-empty token for testing
        // REMOVE THIS IN PRODUCTION
        $request->attributes->set('oauth_token', $token);
{{/isOAuth2}}

        return $next($request);
    }

    /**
     * Return unauthorized response (401)
     *
     * @param string $message
     * @return Response
     */
    private function unauthorized(string $message): Response
    {
        return response()->json([
            'error' => 'Unauthorized',
            'message' => $message,
            'code' => 'UNAUTHORIZED',
        ], 401);
    }
}
